#include "syntax_highlighter.h"
#include "src/core/config_manager.h"
#include <algorithm>
#include <cstring>
#include <fstream>
#include <sstream>
#ifdef _WIN32
#include <curses.h>
#else
#include <ncurses.h>
#endif
#include <iostream>

#ifdef TREE_SITTER_ENABLED
#include "language_registry.h" // Auto-generated by CMake
#include "tree_sitter/api.h"
#endif

SyntaxHighlighter::SyntaxHighlighter()
    : config_loader_(std::make_unique<SyntaxConfigLoader>()),
      current_language_config_(nullptr), currentLanguage("text")
#ifdef TREE_SITTER_ENABLED
      ,
      parser_(nullptr), tree_(nullptr), current_ts_language_(nullptr),
      current_ts_query_(nullptr)
#endif
{
#ifdef TREE_SITTER_ENABLED
  initializeTreeSitter();
#endif
}

SyntaxHighlighter::~SyntaxHighlighter()
{
#ifdef TREE_SITTER_ENABLED
  cleanupTreeSitter();
#endif
}

bool SyntaxHighlighter::initialize(const std::string &config_directory)
{
  // std::cerr << "=== SyntaxHighlighter::initialize ===\n";
  // std::cerr << "Config directory: " << config_directory << std::endl;

  if (!config_loader_->loadAllLanguageConfigs(config_directory))
  {
    std::cerr << "Failed to load language configurations from: "
              << config_directory << std::endl;
    // Fall back to basic highlighting rules
    loadBasicRules();
    return false;
  }
  ConfigManager::registerReloadCallback(
      [this, config_directory]()
      {
        std::cerr << "Syntax config reload triggered." << std::endl;
        // Clear old configs and reload them
        config_loader_->language_configs_.clear();
        config_loader_->extension_to_language_.clear();

        // Reload all config files from the directory
        this->config_loader_->loadAllLanguageConfigs(
            ConfigManager::getSyntaxRulesDir());

        // Re-apply the parser for the current file
        setLanguage(this->currentLanguage); // Re-set language to pick up new
                                            // rules/queries
        // NOTE: Force a full buffer re-highlight/re-parse (e.g., set a flag)
      });

  // std::cout << "Successfully loaded language configurations" << std::endl;
  return true;
}

#ifdef TREE_SITTER_ENABLED

void SyntaxHighlighter::diagnoseGrammar() const
{
  if (!current_ts_language_)
  {
    std::cerr << "ERROR: No language loaded" << std::endl;
    return;
  }

  std::cerr << "=== Grammar Diagnostic ===" << std::endl;
  std::cerr << "ABI Version: " << ts_language_abi_version(current_ts_language_)
            << std::endl;
  std::cerr << "Symbol count: "
            << ts_language_symbol_count(current_ts_language_) << std::endl;

  // Test a simple parse
  const char *test_code = "int x;";
  TSTree *test_tree = ts_parser_parse_string(parser_, nullptr, test_code,
                                             std::strlen(test_code));

  if (test_tree)
  {
    TSNode root = ts_tree_root_node(test_tree);
    char *tree_string = ts_node_string(root);
    std::cerr << "Parse test result: " << tree_string << std::endl;
    free(tree_string);
    ts_tree_delete(test_tree);
  }
  else
  {
    std::cerr << "ERROR: Failed to parse simple test code" << std::endl;
  }

  std::cerr << "=== End Diagnostic ===" << std::endl;
}

#endif

void SyntaxHighlighter::setLanguage(const std::string &extension)
{
  std::string language_name =
      config_loader_->getLanguageFromExtension(extension);

  const LanguageConfig *config =
      config_loader_->getLanguageConfig(language_name);

  if (config)
  {
    current_language_config_ = config;
    currentLanguage = language_name;

#ifdef TREE_SITTER_ENABLED
    if (!config->parser_name.empty() && parser_)
    {
      const TSLanguage *ts_language = getLanguageFunction(config->parser_name);
      if (ts_language)
      {
        if (!ts_parser_set_language(parser_, ts_language))
        {
          std::cerr << "ERROR: Failed to set language for parser" << std::endl;
          loadBasicRules();
          return;
        }
        current_ts_language_ = ts_language;

        // Clean up old query
        if (current_ts_query_)
        {
          ts_query_delete(current_ts_query_);
          current_ts_query_ = nullptr;
        }

        // Load and merge all queries
        if (!config->queries.empty())
        {
          std::string merged_query_source;

          for (const auto &query_path : config->queries)
          {
            std::ifstream file(query_path);
            if (!file.is_open())
            {
              std::cerr << "ERROR: Cannot open query file: " << query_path
                        << std::endl;
              continue;
            }

            std::stringstream buffer;
            buffer << file.rdbuf();
            std::string query_content = buffer.str();

            if (!query_content.empty())
            {
              // Add newline between queries for safety
              if (!merged_query_source.empty())
              {
                merged_query_source += "\n";
              }
              merged_query_source += query_content;
            }
          }

          // Parse the merged query once
          if (!merged_query_source.empty())
          {
            uint32_t error_offset;
            TSQueryError error_type;
            current_ts_query_ = ts_query_new(
                current_ts_language_, merged_query_source.c_str(),
                merged_query_source.length(), &error_offset, &error_type);

            if (!current_ts_query_)
            {
              std::cerr << "ERROR: Failed to parse merged query" << std::endl;
              std::cerr << "  Error offset: " << error_offset << std::endl;
              std::cerr << "  Error type: " << error_type << std::endl;

              // Show context around error
              if (error_offset < merged_query_source.length())
              {
                int context_start = std::max(0, (int)error_offset - 50);
                int context_end = std::min((int)merged_query_source.length(),
                                           (int)error_offset + 50);

                std::cerr << "Context around error:" << std::endl;
                std::cerr << "..."
                          << merged_query_source.substr(
                                 context_start, context_end - context_start)
                          << "..." << std::endl;
                std::cerr << std::string(error_offset - context_start + 3, ' ')
                          << "^" << std::endl;
              }
            }
          }
        }
      }
      else
      {
        std::cerr << "ERROR: No Tree-sitter language function found for: "
                  << config->parser_name << std::endl;
        loadBasicRules();
      }
    }
    else
    {
      std::cerr << "Tree-sitter not available or no parser specified, using "
                   "basic highlighting"
                << std::endl;
      loadBasicRules();
    }
#else
    std::cerr << "Tree-sitter disabled, using basic highlighting" << std::endl;
    loadBasicRules();
#endif
  }
  else
  {
    std::cerr << "ERROR: No config found for language: " << language_name
              << std::endl;
    loadBasicRules();
    currentLanguage = "text";
    current_language_config_ = nullptr;
  }
}

std::vector<ColorSpan>
SyntaxHighlighter::getHighlightSpans(const std::string &line, int lineIndex,
                                     const GapBuffer &buffer) const
{
  // Check cache first
  auto cache_it = line_cache_.find(lineIndex);
  if (cache_it != line_cache_.end())
  {
    return cache_it->second;
  }

  std::vector<ColorSpan> result;

  // Special handling for Markdown block states
  if (currentLanguage == "Markdown" && line_states_.count(lineIndex))
  {
    MarkdownState state = line_states_.at(lineIndex);
    if (state == MarkdownState::IN_FENCED_CODE_BLOCK)
    {
      result = {{0, (int)line.length(),
                 getColorPairValue("MARKDOWN_CODE_BLOCK"), A_NORMAL, 100}};
      line_cache_[lineIndex] = result;
      return result;
    }
    else if (state == MarkdownState::IN_BLOCKQUOTE)
    {
      result = {{0, (int)line.length(),
                 getColorPairValue("MARKDOWN_BLOCKQUOTE"), A_NORMAL, 90}};
      line_cache_[lineIndex] = result;
      return result;
    }
  }

#ifdef TREE_SITTER_ENABLED
  // CRITICAL: Ensure tree is up to date BEFORE querying
  if (current_ts_query_ && current_buffer_content_.empty())
  {
    const_cast<SyntaxHighlighter *>(this)->updateTree(buffer);
  }

  if (current_ts_query_ && tree_)
  {
    try
    {
      result = executeTreeSitterQuery(line, lineIndex);
    }
    catch (const std::exception &e)
    {
      std::cerr << "Tree-sitter query error on line " << lineIndex << ": "
                << e.what() << std::endl;
      result = getBasicHighlightSpans(line);
    }
  }
#endif

  // Fall back to basic highlighting if no Tree-sitter result
  if (result.empty())
  {
    result = getBasicHighlightSpans(line);
  }

  // Cache the result
  line_cache_[lineIndex] = result;
  return result;
}

void SyntaxHighlighter::updateTreeAfterEdit(
    const GapBuffer &buffer, size_t byte_pos, size_t old_byte_len,
    size_t new_byte_len, uint32_t start_row, uint32_t start_col,
    uint32_t old_end_row, uint32_t old_end_col, uint32_t new_end_row,
    uint32_t new_end_col)
{
#ifdef TREE_SITTER_ENABLED
  if (!tree_ || !parser_)
    return;

  // Apply edit to tree
  TSInputEdit edit = {.start_byte = (uint32_t)byte_pos,
                      .old_end_byte = (uint32_t)(byte_pos + old_byte_len),
                      .new_end_byte = (uint32_t)(byte_pos + new_byte_len),
                      .start_point = {start_row, start_col},
                      .old_end_point = {old_end_row, old_end_col},
                      .new_end_point = {new_end_row, new_end_col}};

  ts_tree_edit(tree_, &edit);

  // Get fresh content from buffer
  std::string content;
  int lineCount = buffer.getLineCount();
  for (int i = 0; i < lineCount; i++)
  {
    if (i > 0)
      content += "\n";
    content += buffer.getLine(i);
  }

  // Reparse immediately with old tree
  TSTree *old_tree = tree_;
  tree_ = ts_parser_parse_string(parser_, old_tree, content.c_str(),
                                 content.length());

  if (tree_)
  {
    current_buffer_content_ = content;
    if (old_tree)
    {
      ts_tree_delete(old_tree);
    }
  }
  else
  {
    std::cerr << "ERROR: Reparse failed after edit\n";
    tree_ = old_tree; // Keep old tree rather than crash
  }
#endif
}
void SyntaxHighlighter::bufferChanged(const GapBuffer &buffer)
{
#ifdef TREE_SITTER_ENABLED
  // CRITICAL: Only do full reparse if we don't have a tree yet
  // Incremental edits via notifyEdit() should handle most updates
  if (parser_ && current_ts_language_ && !tree_)
  {
    // std::cerr << "DEBUG: Full reparse - no tree exists\n";
    updateTree(buffer);
  }
  else if (tree_)
  {
    std::cerr
        << "DEBUG: Skipping reparse - tree exists, using incremental edits\n";
    // The tree should already be updated via notifyEdit() calls
    // We only need to update the content cache for query execution
    std::string content;
    int lineCount = buffer.getLineCount();
    for (int i = 0; i < lineCount; i++)
    {
      if (i > 0)
        content += "\n";
      content += buffer.getLine(i);
    }
    current_buffer_content_ = content;
  }
#endif

  // Update markdown state if needed
  if (currentLanguage == "Markdown")
  {
    updateMarkdownState(buffer);
  }

  // CRITICAL: DON'T clear line_cache_ here
  // Cache should only be cleared by invalidateLineRange()
}

#ifdef TREE_SITTER_ENABLED
bool SyntaxHighlighter::initializeTreeSitter()
{
  parser_ = ts_parser_new();
  if (!parser_)
  {
    std::cerr << "ERROR: Failed to create Tree-sitter parser" << std::endl;
    return false;
  }

  // Auto-register all languages from generated header
  registerAllLanguages(language_registry_);

  // std::cerr << "Tree-sitter initialized with " << language_registry_.size()
  //           << " language parser(s)" << std::endl;

  return true;
}

void SyntaxHighlighter::cleanupTreeSitter()
{
  // Wait for background thread
  while (is_parsing_)
  {
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
  }

  std::lock_guard<std::mutex> lock(tree_mutex_); // ADD LOCK

  if (current_ts_query_)
  {
    ts_query_delete(current_ts_query_);
    current_ts_query_ = nullptr;
  }

  if (tree_)
  {
    ts_tree_delete(tree_);
    tree_ = nullptr;
  }

  if (parser_)
  {
    ts_parser_delete(parser_);
    parser_ = nullptr;
  }
}

const TSLanguage *
SyntaxHighlighter::getLanguageFunction(const std::string &parser_name)
{
  auto it = language_registry_.find(parser_name);
  if (it != language_registry_.end())
  {
    return it->second(); // Call the function pointer
  }

  // Enhanced error message showing available languages
  std::cerr << "WARNING: No Tree-sitter language found for: '" << parser_name
            << "'" << std::endl;
  std::cerr << "  Available languages: ";
  bool first = true;
  for (const auto &pair : language_registry_)
  {
    if (!first)
      std::cerr << ", ";
    std::cerr << pair.first;
    first = false;
  }
  std::cerr << std::endl;

  return nullptr;
}

TSQuery *
SyntaxHighlighter::loadQueryFromFile(const std::string &query_file_path)
{
  std::ifstream file(query_file_path);
  if (!file.is_open())
  {
    std::cerr << "ERROR: Cannot open query file: " << query_file_path
              << std::endl;
    return nullptr;
  }

  std::stringstream buffer;
  buffer << file.rdbuf();
  std::string query_source = buffer.str();

  if (query_source.empty())
  {
    std::cerr << "ERROR: Query file is empty: " << query_file_path << std::endl;
    return nullptr;
  }

  // Debug: Print the query source around the error offset
  // std::cerr << "Query source length: " << query_source.length() << "
  // characters"
  //           << std::endl;

  uint32_t error_offset;
  TSQueryError error_type;
  TSQuery *query =
      ts_query_new(current_ts_language_, query_source.c_str(),
                   query_source.length(), &error_offset, &error_type);

  if (!query)
  {
    std::cerr << "ERROR: Failed to parse query file " << query_file_path
              << std::endl;
    std::cerr << "  Error offset: " << error_offset << std::endl;
    std::cerr << "  Error type: " << error_type;

    // Provide more detailed error information
    switch (error_type)
    {
    case TSQueryErrorNone:
      std::cerr << " (None)";
      break;
    case TSQueryErrorSyntax:
      std::cerr << " (Syntax Error)";
      break;
    case TSQueryErrorNodeType:
      std::cerr << " (Unknown Node Type)";
      break;
    case TSQueryErrorField:
      std::cerr << " (Unknown Field)";
      break;
    case TSQueryErrorCapture:
      std::cerr << " (Unknown Capture)";
      break;
    case TSQueryErrorStructure:
      std::cerr << " (Invalid Structure)";
      break;
    default:
      std::cerr << " (Unknown Error)";
      break;
    }
    std::cerr << std::endl;

    // Show context around error
    if (error_offset < query_source.length())
    {
      int context_start = std::max(0, (int)error_offset - 50);
      int context_end =
          std::min((int)query_source.length(), (int)error_offset + 50);

      std::cerr << "Context around error:" << std::endl;
      std::cerr << "..."
                << query_source.substr(context_start,
                                       context_end - context_start)
                << "..." << std::endl;

      // Point to error location
      std::cerr << std::string(error_offset - context_start + 3, ' ') << "^"
                << std::endl;
    }

    return nullptr;
  }

  // std::cerr << "Successfully loaded query from: " << query_file_path
  //           << std::endl;
  return query;
}

void SyntaxHighlighter::notifyEdit(size_t byte_pos, size_t old_byte_len,
                                   size_t new_byte_len, uint32_t start_row,
                                   uint32_t start_col, uint32_t old_end_row,
                                   uint32_t old_end_col, uint32_t new_end_row,
                                   uint32_t new_end_col)
{
#ifdef TREE_SITTER_ENABLED
  if (!tree_)
  {
    std::cerr << "WARNING: notifyEdit called but no tree exists\n";
    return;
  }

  TSInputEdit edit = {.start_byte = (uint32_t)byte_pos,
                      .old_end_byte = (uint32_t)(byte_pos + old_byte_len),
                      .new_end_byte = (uint32_t)(byte_pos + new_byte_len),
                      .start_point = {start_row, start_col},
                      .old_end_point = {old_end_row, old_end_col},
                      .new_end_point = {new_end_row, new_end_col}};

  ts_tree_edit(tree_, &edit);

  // CRITICAL FIX: Mark that we need to reparse on next access
  // This forces updateTree() to be called on next getHighlightSpans()
  current_buffer_content_.clear();
#endif
}

void SyntaxHighlighter::invalidateLineRange(int startLine, int endLine)
{
  // std::cerr << "DEBUG: Invalidating lines " << startLine << " to " << endLine
  //           << "\n";

  // Only clear cache for affected lines
  for (int i = startLine; i <= endLine; ++i)
  {
    line_cache_.erase(i);
  }

  // If we're invalidating many lines, trigger a reparse on next display
  if (endLine - startLine > 50)
  {
    // std::cerr << "DEBUG: Large invalidation, clearing tree for reparse\n";
    // This forces a full reparse on next getHighlightSpans call
    current_buffer_content_.clear();
  }
}

void SyntaxHighlighter::updateTree(const GapBuffer &buffer)
{
#ifdef TREE_SITTER_ENABLED
  std::string content;
  int lineCount = buffer.getLineCount();

  // Build line offset cache while building content
  line_byte_offsets_.clear();
  line_byte_offsets_.reserve(lineCount + 1);
  line_byte_offsets_.push_back(0); // First line starts at byte 0

  for (int i = 0; i < lineCount; i++)
  {
    if (i > 0)
      content += "\n";
    content += buffer.getLine(i);

    // Store the byte offset for the next line
    line_byte_offsets_.push_back(content.length());
  }

  if (content.empty())
  {
    std::cerr << "WARNING: Attempting to parse empty buffer\n";
    return;
  }

  std::lock_guard<std::mutex> lock(tree_mutex_);
  current_buffer_content_ = content;

  if (!tree_)
  {
    tree_ = ts_parser_parse_string(parser_, nullptr, content.c_str(),
                                   content.length());
  }
  else
  {
    TSTree *old_tree = tree_;
    tree_ = ts_parser_parse_string(parser_, old_tree, content.c_str(),
                                   content.length());
    if (old_tree && tree_)
    {
      ts_tree_delete(old_tree);
    }
  }

  if (!tree_)
  {
    std::cerr << "ERROR: Failed to parse tree\n";
  }
#endif
}

void SyntaxHighlighter::markViewportLines(int startLine, int endLine) const
{
  priority_lines_.clear();
  for (int i = startLine; i <= endLine; ++i)
  {
    priority_lines_.insert(i);
  }
}

bool SyntaxHighlighter::isLineHighlighted(int lineIndex) const
{
  return line_cache_.find(lineIndex) != line_cache_.end();
}

std::vector<ColorSpan>
SyntaxHighlighter::executeTreeSitterQuery(const std::string &line,
                                          int lineNum) const
{
  if (!current_ts_query_ || !tree_)
    return {};

  std::lock_guard<std::mutex> lock(tree_mutex_);
  std::vector<ColorSpan> spans;
  TSQueryCursor *cursor = ts_query_cursor_new();
  TSNode root_node = ts_tree_root_node(tree_);

  int adjusted_line =
      is_full_parse_ ? lineNum : (lineNum - viewport_start_line_);
  if (adjusted_line < 0 ||
      adjusted_line >= ts_node_end_point(root_node).row + 1)
  {
    ts_query_cursor_delete(cursor);
    return {};
  }

  // Calculate byte range for current line
  uint32_t line_start_byte = 0;
  uint32_t line_end_byte = 0;

  std::istringstream content_stream(current_buffer_content_);
  std::string content_line;
  int current_line = 0;

  while (std::getline(content_stream, content_line) && current_line <= lineNum)
  {
    if (current_line == lineNum)
    {
      line_end_byte = line_start_byte + content_line.length();
      break;
    }
    line_start_byte += content_line.length() + 1;
    current_line++;
  }

  ts_query_cursor_set_byte_range(cursor, line_start_byte, line_end_byte);
  ts_query_cursor_exec(cursor, current_ts_query_, root_node);

  TSQueryMatch match;
  while (ts_query_cursor_next_match(cursor, &match))
  {
    for (uint32_t i = 0; i < match.capture_count; i++)
    {
      TSQueryCapture capture = match.captures[i];
      TSNode node = capture.node;

      TSPoint start_point = ts_node_start_point(node);
      TSPoint end_point = ts_node_end_point(node);

      // ORIGINAL: Only process captures starting on current line
      // Check if this capture affects the current line
      if (start_point.row <= (uint32_t)lineNum &&
          end_point.row >= (uint32_t)lineNum)
      {
        uint32_t name_length;
        const char *capture_name_ptr = ts_query_capture_name_for_id(
            current_ts_query_, capture.index, &name_length);
        std::string capture_name(capture_name_ptr, name_length);

        int start_col =
            (start_point.row == (uint32_t)lineNum) ? start_point.column : 0;
        int end_col = (end_point.row == (uint32_t)lineNum) ? end_point.column
                                                           : (int)line.length();

        start_col = std::max(0, std::min(start_col, (int)line.length()));
        end_col = std::max(start_col, std::min(end_col, (int)line.length()));

        if (start_col < end_col)
        {
          int color_pair = getColorPairForCapture(capture_name);
          spans.push_back({start_col, end_col, color_pair, 0, 100});
        }
      }
    }
  }

  ts_query_cursor_delete(cursor);
  return spans;
}

int SyntaxHighlighter::getColorPairForCapture(
    const std::string &capture_name) const
{
  static const std::unordered_map<std::string, std::string> capture_to_color = {
      // Keywords
      {"keyword", "KEYWORD"},
      {"keyword.control", "KEYWORD"},
      {"keyword.function", "KEYWORD"},
      {"keyword.operator", "KEYWORD"},
      {"keyword.return", "KEYWORD"},
      {"keyword.conditional", "KEYWORD"},
      {"keyword.repeat", "KEYWORD"},
      {"keyword.import", "KEYWORD"},
      {"keyword.exception", "KEYWORD"},

      // Types
      {"type", "TYPE"},
      {"type.builtin", "TYPE"},
      {"type.definition", "TYPE"},
      {"class", "TYPE"},
      {"interface", "TYPE"},

      // Functions
      {"function", "FUNCTION"},
      {"function.call", "FUNCTION"},
      {"function.builtin", "FUNCTION"},
      {"function.method", "FUNCTION"},
      {"method", "FUNCTION"},

      // Variables & constants

      {"variable", "VARIABLE"},
      {"variable.parameter", "VARIABLE"},
      {"variable.builtin", "CONSTANT"},
      {"variable.member", "VARIABLE"},
      {"constant", "CONSTANT"},
      {"constant.builtin", "CONSTANT"},
      {"parameter", "VARIABLE"},

      // Literals
      {"string", "STRING_LITERAL"},
      {"string_literal", "STRING_LITERAL"},
      {"number", "NUMBER"},
      {"integer", "NUMBER"},
      {"float", "NUMBER"},
      {"boolean", "CONSTANT"},

      // Comments
      {"comment", "COMMENT"},

      // Operators & punctuation
      {"operator", "OPERATOR"},
      {"punctuation", "PUNCTUATION"},
      {"punctuation.bracket", "PUNCTUATION"},
      {"punctuation.delimiter", "PUNCTUATION"},

      // Specialized
      {"namespace", "NAMESPACE"},
      {"property", "PROPERTY"},
      {"field", "PROPERTY"},
      {"attribute", "DECORATOR"},
      {"decorator", "DECORATOR"},
      {"label", "LABEL"},
      {"tag", "LABEL"},

      // Preprocessor/macro
      {"preproc", "MACRO"},
      {"preproc_include", "MACRO"},
      {"preproc_def", "MACRO"},
      {"preproc_call", "MACRO"},
      {"preproc_if", "MACRO"},
      {"preproc_ifdef", "MACRO"},
      {"preproc_ifndef", "MACRO"},
      {"preproc_else", "MACRO"},
      {"preproc_elif", "MACRO"},
      {"preproc_endif", "MACRO"},
      {"macro", "MACRO"},

      // Markup (Markdown, etc.)
      {"markup.heading", "MARKUP_HEADING"},
      {"heading", "MARKUP_HEADING"},
      {"markup.bold", "MARKUP_BOLD"},
      {"markup.italic", "MARKUP_ITALIC"},
      {"emphasis", "MARKUP_ITALIC"},
      {"markup.code", "MARKUP_CODE"},
      {"code", "MARKUP_CODE"},
      {"markup.link", "MARKUP_LINK"},
      {"link_text", "MARKUP_LINK"},
      {"markup.url", "MARKUP_URL"},
      {"link_uri", "MARKUP_URL"},
      {"markup.quote", "MARKUP_BLOCKQUOTE"},
      {"markup.list", "MARKUP_LIST"},
      {"markup.code", "MARKUP_CODE"},
      {"code_fence_content", "MARKUP_CODE_BLOCK"},
      {"code_span", "MARKUP_CODE"},

      // Markdown structure
      {"markup.list", "MARKUP_LIST"},
      {"markup.quote", "MARKUP_BLOCKQUOTE"},
  };

  auto it = capture_to_color.find(capture_name);
  if (it != capture_to_color.end())
  {
    return getColorPairValue(it->second);
  }

  // Fallback: hierarchical matching
  if (capture_name.find("keyword") != std::string::npos)
    return getColorPairValue("KEYWORD");
  if (capture_name.find("type") != std::string::npos)
    return getColorPairValue("TYPE");
  if (capture_name.find("function") != std::string::npos)
    return getColorPairValue("FUNCTION");
  if (capture_name.find("string") != std::string::npos)
    return getColorPairValue("STRING_LITERAL");
  if (capture_name.find("comment") != std::string::npos)
    return getColorPairValue("COMMENT");
  if (capture_name.find("number") != std::string::npos)
    return getColorPairValue("NUMBER");
  if (capture_name.find("constant") != std::string::npos)
    return getColorPairValue("CONSTANT");

  return 0; // Default
}
#endif

// Color and attribute mapping (unchanged from original)
int SyntaxHighlighter::getColorPairValue(const std::string &color_name) const
{
  static const std::unordered_map<std::string, int> color_map = {
      {"COMMENT", COMMENT},
      {"KEYWORD", KEYWORD},
      {"STRING_LITERAL", STRING_LITERAL},
      {"NUMBER", NUMBER},
      {"FUNCTION", FUNCTION},
      {"VARIABLE", VARIABLE},
      {"TYPE", TYPE},
      {"OPERATOR", OPERATOR},
      {"PUNCTUATION", PUNCTUATION},
      {"CONSTANT", CONSTANT},
      {"NAMESPACE", NAMESPACE},
      {"PROPERTY", PROPERTY},
      {"DECORATOR", DECORATOR},
      {"MACRO", MACRO},
      {"LABEL", LABEL},
      {"MARKUP_HEADING", MARKUP_HEADING},
      {"MARKUP_BOLD", MARKUP_BOLD},
      {"MARKUP_ITALIC", MARKUP_ITALIC},
      {"MARKUP_CODE", MARKUP_CODE},
      {"MARKUP_CODE_BLOCK", MARKUP_CODE_BLOCK},
      {"MARKUP_LINK", MARKUP_LINK},
      {"MARKUP_URL", MARKUP_URL},
      {"MARKUP_LIST", MARKUP_LIST},
      {"MARKUP_BLOCKQUOTE", MARKUP_BLOCKQUOTE},
      {"MARKUP_STRIKETHROUGH", MARKUP_STRIKETHROUGH},
      {"MARKUP_QUOTE", MARKUP_QUOTE}};

  auto it = color_map.find(color_name);
  return (it != color_map.end()) ? it->second : 0;
}

int SyntaxHighlighter::getAttributeValue(
    const std::string &attribute_name) const
{
  static const std::unordered_map<std::string, int> attribute_map = {
      {"0", 0},
      {"A_BOLD", A_BOLD},
      {"A_DIM", A_DIM},
      {"A_UNDERLINE", A_UNDERLINE},
      {"A_REVERSE", A_REVERSE}};

  auto it = attribute_map.find(attribute_name);
  return (it != attribute_map.end()) ? it->second : 0;
}

std::vector<ColorSpan>
SyntaxHighlighter::getBasicHighlightSpans(const std::string &line) const
{
  std::vector<ColorSpan> spans;

  // Very basic regex-based highlighting as fallback
  // Comments (# and //)
  size_t comment_pos = line.find('#');
  if (comment_pos == std::string::npos)
  {
    comment_pos = line.find("//");
  }
  if (comment_pos != std::string::npos)
  {
    spans.push_back({static_cast<int>(comment_pos),
                     static_cast<int>(line.length()),
                     getColorPairValue("COMMENT"), 0, 100});
  }

  // Simple string detection (basic)
  bool in_string = false;
  char string_char = 0;
  size_t string_start = 0;

  for (size_t i = 0; i < line.length(); i++)
  {
    char c = line[i];
    if (!in_string && (c == '"' || c == '\''))
    {
      in_string = true;
      string_char = c;
      string_start = i;
    }
    else if (in_string && c == string_char && (i == 0 || line[i - 1] != '\\'))
    {
      spans.push_back({static_cast<int>(string_start), static_cast<int>(i + 1),
                       getColorPairValue("STRING_LITERAL"), 0, 90});
      in_string = false;
    }
  }

  return spans;
}

void SyntaxHighlighter::loadBasicRules()
{
  // This is called as a fallback when Tree-sitter is not available
  std::cerr << "Loading basic highlighting rules (fallback mode)" << std::endl;
}

// Markdown state management (unchanged from original)
void SyntaxHighlighter::updateMarkdownState(const GapBuffer &buffer)
{
  if (currentLanguage != "Markdown")
  {
    line_states_.clear();
    return;
  }

  line_states_.clear();
  MarkdownState currentState = MarkdownState::DEFAULT;

  int lineCount = buffer.getLineCount();
  for (int i = 0; i < lineCount; ++i)
  {
    std::string line = buffer.getLine(i);
    line_states_[i] = currentState;

    if (currentState == MarkdownState::DEFAULT)
    {
      if (line.rfind("```", 0) == 0)
      {
        currentState = MarkdownState::IN_FENCED_CODE_BLOCK;
      }
      else if (line.rfind(">", 0) == 0)
      {
        line_states_[i] = MarkdownState::IN_BLOCKQUOTE;
      }
    }
    else if (currentState == MarkdownState::IN_FENCED_CODE_BLOCK)
    {
      if (line.rfind("```", 0) == 0)
      {
        currentState = MarkdownState::DEFAULT;
      }
      line_states_[i] = MarkdownState::IN_FENCED_CODE_BLOCK;
    }
  }
}

std::vector<std::string> SyntaxHighlighter::getSupportedExtensions() const
{
  return {"cpp", "h", "hpp", "c", "py", "md", "txt"};
}

void SyntaxHighlighter::debugTreeSitterState() const
{
#ifdef TREE_SITTER_ENABLED
  std::cerr << "=== Tree-sitter State Debug ===\n";
  std::cerr << "Current language: " << currentLanguage << "\n";
  std::cerr << "Parser: " << (parser_ ? "EXISTS" : "NULL") << "\n";
  std::cerr << "Tree: " << (tree_ ? "EXISTS" : "NULL") << "\n";
  std::cerr << "TS Language: " << (current_ts_language_ ? "EXISTS" : "NULL")
            << "\n";
  std::cerr << "TS Query: " << (current_ts_query_ ? "EXISTS" : "NULL") << "\n";
  std::cerr << "Buffer content length: " << current_buffer_content_.length()
            << "\n";
  std::cerr << "Line cache size: " << line_cache_.size() << "\n";

  if (tree_)
  {
    TSNode root = ts_tree_root_node(tree_);
    char *tree_str = ts_node_string(root);
    std::cerr << "Parse tree (truncated): "
              << std::string(tree_str).substr(0, 200) << "...\n";
    free(tree_str);
  }
  std::cerr << "=== End Debug ===\n";
#else
  std::cerr << "Tree-sitter not enabled\n";
#endif
}

void SyntaxHighlighter::parseViewportOnly(const GapBuffer &buffer,
                                          int targetLine)
{
#ifdef TREE_SITTER_ENABLED
  if (!parser_ || !current_ts_language_)
    return;

  int startLine = std::max(0, targetLine - 50);
  int endLine = std::min(buffer.getLineCount() - 1, targetLine + 50);

  std::string content;
  for (int i = startLine; i <= endLine; i++)
  {
    if (i > startLine)
      content += "\n";
    content += buffer.getLine(i);
  }

  if (content.empty())
    return;

  TSTree *new_tree = ts_parser_parse_string(parser_, nullptr, content.c_str(),
                                            content.length());

  if (new_tree)
  {
    std::lock_guard<std::mutex> lock(tree_mutex_); // LOCK ADDED
    if (tree_)
      ts_tree_delete(tree_);
    tree_ = new_tree;
    current_buffer_content_ = content;
    viewport_start_line_ = startLine;
    is_full_parse_ = false;
  }
#endif
}

void SyntaxHighlighter::scheduleBackgroundParse(const GapBuffer &buffer)
{
#ifdef TREE_SITTER_ENABLED
  if (is_parsing_ || !parser_ || !current_ts_language_)
    return;

  std::string content;
  int lineCount = buffer.getLineCount();
  for (int i = 0; i < lineCount; i++)
  {
    if (i > 0)
      content += "\n";
    content += buffer.getLine(i);
  }

  if (content.empty())
    return;

  is_parsing_ = true;
  parse_complete_ = false;

  parse_thread_ = std::thread(
      [this, content]() // Capture by value
      {
        TSTree *new_tree = ts_parser_parse_string(
            parser_, nullptr, content.c_str(), content.length());

        if (new_tree)
        {
          std::lock_guard<std::mutex> lock(tree_mutex_); // LOCK ADDED

          TSTree *old_tree = tree_;
          tree_ = new_tree;
          current_buffer_content_ = content;
          is_full_parse_ = true;

          if (old_tree)
            ts_tree_delete(old_tree);
        }

        is_parsing_ = false;
        parse_complete_ = true;
      });

  parse_thread_.detach();
#endif
}